<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://416426.github.io</id>
    <title>狐白de博客</title>
    <updated>2021-09-13T01:37:21.473Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://416426.github.io"/>
    <link rel="self" href="https://416426.github.io/atom.xml"/>
    <subtitle>记录生活点点滴滴</subtitle>
    <logo>https://416426.github.io/images/avatar.png</logo>
    <icon>https://416426.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, 狐白de博客</rights>
    <entry>
        <title type="html"><![CDATA[爬虫]]></title>
        <id>https://416426.github.io/pa-chong/</id>
        <link href="https://416426.github.io/pa-chong/">
        </link>
        <updated>2021-09-11T11:50:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="爬虫的概念">爬虫的概念</h3>
<ul>
<li>模拟客户端发送网络请求  获取响应  按照规则提取数据的程序</li>
</ul>
<h3 id="浏览器请求">浏览器请求</h3>
<ul>
<li>url
<ul>
<li>在chrome -- 点检查 --  点network</li>
<li>url = 请求协议+网站域名+资源的路径+参数</li>
</ul>
</li>
<li>浏览器请求url地址
<ul>
<li>当前url对应的响应+js+css+图片   ------&gt; elements中的内容</li>
</ul>
</li>
<li>爬虫请求url地址
<ul>
<li>当前的url对应的响应</li>
</ul>
</li>
<li>elements的内容和爬虫获取的url地址响应不同，爬虫需要以当前url地址对应的响应为准提取数据</li>
<li>当前URL地址对应的响应在
<ul>
<li>从network中找到当前url地址	点击response</li>
<li>页面右键显示网页源码</li>
</ul>
</li>
</ul>
<h3 id="http-https">HTTP    HTTPS</h3>
<ul>
<li>
<p>HTTP：超文本传输协议</p>
<ul>
<li>明文形式传输</li>
<li>效率更高，但不安全</li>
</ul>
</li>
<li>
<p>HTTPS： HTTP+ SSL（安全套接字层）</p>
<ul>
<li>传输前数据先加密， 之后解密获取内容</li>
<li>效率较低，但是安全</li>
</ul>
</li>
<li>
<p>HTTP协议及请求</p>
<ul>
<li>
<p>General  -  请求参数</p>
<ul>
<li>url地址</li>
<li>请求方式</li>
<li>状态码</li>
</ul>
</li>
<li>
<p>Response Headers -  响应头</p>
</li>
<li>
<p>Request  Headers  -  请求头</p>
<ul>
<li>
<p>点 View  source</p>
<p>请求行 -- get -请求方式</p>
</li>
<li>
<p>get请求和post请求的区别</p>
</li>
<li>
<p>get请求没有请求体， post有，get请求把数据放到url地址中</p>
<ul>
<li>post请求常用与登陆注册</li>
<li>post请求携带的数据量比get请求大，多，常用语传输打文本的时候</li>
</ul>
</li>
<li>
<p>请求头</p>
<ol>
<li>
<p><strong>User-Agent</strong>： 用户代理： 对方服务器可以通过user_agent知道当前请求对方资源的是什么浏览器</p>
<p>​	若果我们需要模拟手机版浏览器发送请求 ，对应的就需要把user_agent改成手机版</p>
</li>
<li>
<p><strong>Cookie</strong>: 用于存储用户信息，每次请求携带上发送给对方浏览器</p>
<ul>
<li>要获取登陆后才能访问的页面</li>
<li>对方服务器回通过cookie判断我们是不是一个爬虫</li>
<li>name ----- value</li>
</ul>
</li>
</ol>
</li>
<li>
<p>请求体</p>
<ul>
<li>携带数据</li>
<li>get请求没有请求体</li>
<li>post有请求体</li>
</ul>
</li>
</ul>
</li>
<li>
<p>HTTP协议--响应</p>
<ul>
<li>
<ol>
<li>
<p>响应头</p>
<p>Set-Cookie： 对方服务通过该字段设置cookie到本地</p>
</li>
</ol>
</li>
<li>
<ol start="2">
<li>
<p>响应体</p>
<p>url地址对应的响应</p>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Query String Parameters -  请求参数</p>
</li>
</ul>
</li>
</ul>
<h3 id="requests模块"><strong>requests模块</strong></h3>
<ol>
<li>
<p><strong>安装 --- pip install requests</strong></p>
</li>
<li>
<p><strong>发送get post请求  获取响应</strong></p>
<ol>
<li>response  =  requests.get(url)    # 发送get请求， 请求url对应的响应</li>
<li>response = requests.post(url, data = {请求题的字典})  ## 发送post请求， 请求的url地址对应的响应</li>
</ol>
</li>
<li>
<p><strong>response的方法</strong></p>
<ol>
<li>​	response.text
<ol>
<li>该方式常出现乱码, 原因是编码解码方式不一样，出现乱码使用<strong>response.encoding = &quot;utf-8&quot;</strong></li>
</ol>
</li>
<li>response.content.decode()
<ol>
<li>把响应的二进制字节流转化为str类型</li>
</ol>
</li>
<li>response.request.url  # 发送请求的url地址</li>
<li>response.url  # response响应的url地址</li>
<li>response.requset.headers  #请求头</li>
<li>response.headers # 响应头</li>
</ol>
</li>
<li>
<p><strong>获取网页源码的正确打开方式（一定可以获取到）</strong></p>
<ol>
<li>response.content.decode()</li>
<li>response.content.decode(“gbk”)</li>
<li>response.text</li>
</ol>
<ul>
<li>直接使用response.content.decode()获取，获取不到的话使用response.content.decode(“gbk”)国标码尝试，如果都获取不到response.text一定可以拿到</li>
</ul>
</li>
<li>
<p><strong>发送带header的请求</strong></p>
<pre><code class="language-python">headers = {&quot;User-Agent&quot;:&quot; Mozilla/5.0 (iPhone; CPU iPhone OS 13_2_3 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.0.3 Mobile/15E148 Safari/604.1&quot;
&quot;Referer&quot;:&quot; https://fanyi.baidu.com/?aldtype=16047&quot;}

response = sequests.get(url, headers=headers)
</code></pre>
<ul>
<li>当请求网页发现带一个键值对依然不可以请求成功，可以尝试带更多的键值对，这是根据对方服务器的一个判断进行尝试，可以把除了cookie的全部键值对都带这进行尝试，如果依然不可以，把cookie也带着请求 ---- <strong>大部分情况User-Agent足以</strong></li>
</ul>
</li>
<li>
<p><strong>使用超时参数</strong></p>
<ol>
<li>requests.get(url, headers=headers, timeout=3)
<ol>
<li>timeout=3 --- 3秒内必须返回响应，否则回报错</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>​</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>https://416426.github.io/hello-gridea/</id>
        <link href="https://416426.github.io/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>